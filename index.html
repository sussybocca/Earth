<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAP EARTH ¬∑ robotic atlas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            background: #0a0f0f;
            color: #00ffc3;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 20, 20, 0.8);
            padding: 12px 24px;
            border: 1px solid #00ffc3;
            box-shadow: 0 0 20px #00ffc3;
            backdrop-filter: blur(5px);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        #drawing-panel {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 10, 10, 0.95);
            border: 2px solid #ff00c1;
            box-shadow: 0 0 30px #ff00c1;
            padding: 20px;
            border-radius: 12px;
            display: none;
            z-index: 20;
            backdrop-filter: blur(8px);
            color: #fff;
        }
        #drawing-panel.active { display: block; }
        #drawing-panel h3 {
            margin: 0 0 15px 0;
            color: #ff00c1;
            text-align: center;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            background: #111;
            padding: 10px;
            border: 1px solid #00ffc3;
        }
        #draw-canvas {
            width: 256px;
            height: 256px;
            background: #1a1a1a;
            cursor: crosshair;
            border: 2px solid #00ffc3;
        }
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        .toolbar button, .toolbar input {
            background: #0f0f0f;
            border: 1px solid #00ffc3;
            color: #00ffc3;
            padding: 8px 16px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
        }
        .toolbar button:hover {
            background: #00ffc3;
            color: #000;
            box-shadow: 0 0 15px #00ffc3;
        }
        .toolbar input[type="color"] {
            width: 50px;
            height: 40px;
            padding: 2px;
        }
        #landmark-name {
            width: 100%;
            padding: 10px;
            background: #0f0f0f;
            border: 1px solid #ff00c1;
            color: #ff00c1;
            font-family: inherit;
            margin-bottom: 15px;
        }
        .actions {
            display: flex;
            justify-content: space-between;
        }
        .actions button {
            flex: 1;
            margin: 0 5px;
            background: transparent;
            border: 2px solid;
        }
        .actions button.save { border-color: #00ffc3; color: #00ffc3; }
        .actions button.cancel { border-color: #ff00c1; color: #ff00c1; }
        #status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 15;
            color: #ff00c1;
            text-shadow: 0 0 10px currentColor;
            font-size: 12px;
        }
        .coords {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border: 1px solid #ff00c1;
            color: #ff00c1;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">üåç MAP EARTH // ROBOTIC LANDMARKS</div>
    <div class="coords" id="coords">LAT: -- LONG: --</div>
    <div id="status">SYSTEM: ONLINE // FETCHING LANDMARKS...</div>

    <div id="drawing-panel">
        <h3>‚ö° DESIGN YOUR LANDMARK ‚ö°</h3>
        <input type="text" id="landmark-name" placeholder="ENTER DESIGNATION" maxlength="30">
        <div class="canvas-container">
            <canvas id="draw-canvas" width="256" height="256"></canvas>
        </div>
        <div class="toolbar">
            <button id="brush">BRUSH</button>
            <button id="eraser">ERASER</button>
            <input type="color" id="color-picker" value="#00ffc3">
            <button id="clear">CLEAR</button>
        </div>
        <div class="actions">
            <button class="save" id="save-landmark">‚ñ∂ UPLOAD TO ORBIT</button>
            <button class="cancel" id="cancel-draw">‚úï CANCEL</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // --- Configuration ---
        const EARTH_RADIUS = 5;
        const API_BASE = '/api/landmarks';  // relative to Vercel deployment

        // --- Setup scene with robotic aesthetic ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050a0a);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 15);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; // not needed
        document.body.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enableZoom = true;
        controls.maxPolarAngle = Math.PI / 2;

        // --- Lighting ---
        const ambient = new THREE.AmbientLight(0x404060);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(1, 2, 1);
        scene.add(dirLight);
        
        // Colored point lights for cyberpunk feel
        const light1 = new THREE.PointLight(0x00ffc3, 0.5, 20);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.PointLight(0xff00c1, 0.5, 20);
        light2.position.set(-5, -2, 5);
        scene.add(light2);

        // --- Procedural Earth (no external images) ---
        const earthGroup = new THREE.Group();

        // Base sphere with dark metallic look
        const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 32);
        const material = new THREE.MeshPhongMaterial({
            color: 0x112222,
            emissive: 0x002222,
            shininess: 30,
            transparent: true,
            opacity: 0.9
        });
        const earth = new THREE.Mesh(geometry, material);
        earth.castShadow = false;
        earth.receiveShadow = false;
        earthGroup.add(earth);

        // Glowing wireframe overlay
        const wireframeGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.005, 32, 16);
        const wireframeMat = new THREE.MeshBasicMaterial({
            color: 0x00ffc3,
            wireframe: true,
            transparent: true,
            opacity: 0.2
        });
        const wireframeSphere = new THREE.Mesh(wireframeGeo, wireframeMat);
        earthGroup.add(wireframeSphere);

        // Add longitude/latitude lines manually for robotic precision
        const linesMaterial = new THREE.LineBasicMaterial({ color: 0x00ffc3 });
        
        // Longitude lines (every 30¬∞)
        for (let i = 0; i < 360; i += 30) {
            const points = [];
            for (let lat = -80; lat <= 80; lat += 5) {
                const phi = THREE.MathUtils.degToRad(90 - lat);
                const theta = THREE.MathUtils.degToRad(i);
                const x = EARTH_RADIUS * Math.sin(phi) * Math.cos(theta);
                const y = EARTH_RADIUS * Math.cos(phi);
                const z = EARTH_RADIUS * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, linesMaterial);
            earthGroup.add(line);
        }

        // Latitude lines (every 30¬∞)
        for (let lat = -60; lat <= 60; lat += 30) {
            const points = [];
            const phi = THREE.MathUtils.degToRad(90 - lat);
            for (let lon = 0; lon <= 360; lon += 5) {
                const theta = THREE.MathUtils.degToRad(lon);
                const x = EARTH_RADIUS * Math.sin(phi) * Math.cos(theta);
                const y = EARTH_RADIUS * Math.cos(phi);
                const z = EARTH_RADIUS * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, linesMaterial);
            earthGroup.add(line);
        }

        // Add two polar rings
        const ringPoints = [];
        for (let lon = 0; lon <= 360; lon += 5) {
            const theta = THREE.MathUtils.degToRad(lon);
            const x = EARTH_RADIUS * Math.cos(theta);
            const y = 0;
            const z = EARTH_RADIUS * Math.sin(theta);
            ringPoints.push(new THREE.Vector3(x, y, z));
        }
        const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPoints);
        const ringLine = new THREE.Line(ringGeo, new THREE.LineBasicMaterial({ color: 0xff00c1 }));
        earthGroup.add(ringLine);

        scene.add(earthGroup);

        // --- Floating particles (robotic dust) ---
        const particleGeo = new THREE.BufferGeometry();
        const particleCount = 800;
        const posArray = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount * 3; i += 3) {
            const r = EARTH_RADIUS + 0.5 + Math.random() * 1.5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray[i] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i+1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i+2] = r * Math.cos(phi);
        }
        particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particleMat = new THREE.PointsMaterial({ color: 0x00ffc3, size: 0.03, transparent: true });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // --- Drawing canvas logic ---
        const canvas = document.getElementById('draw-canvas');
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = '#00ffc3';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        let drawing = false;
        let brushColor = '#00ffc3';
        let brushSize = 4;
        let isErasing = false;
        
        // Fill with black background
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function startDrawing(e) {
            drawing = true;
            ctx.beginPath();
            const pos = getCanvasCoordinates(e);
            ctx.moveTo(pos.x, pos.y);
        }

        function draw(e) {
            if (!drawing) return;
            e.preventDefault();
            const pos = getCanvasCoordinates(e);
            ctx.strokeStyle = isErasing ? '#1a1a1a' : brushColor;
            ctx.lineWidth = brushSize;
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        }

        function stopDrawing() { drawing = false; }

        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        document.getElementById('brush').addEventListener('click', () => {
            isErasing = false;
            brushColor = document.getElementById('color-picker').value;
        });
        document.getElementById('eraser').addEventListener('click', () => {
            isErasing = true;
        });
        document.getElementById('color-picker').addEventListener('input', (e) => {
            brushColor = e.target.value;
            if (!isErasing) ctx.strokeStyle = brushColor;
        });
        document.getElementById('clear').addEventListener('click', () => {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });

        // --- State for current selected location ---
        let selectedLat = 0, selectedLng = 0;

        // --- Raycaster for clicking on Earth ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (event) => {
            // Ignore if drawing panel is open
            if (document.getElementById('drawing-panel').classList.contains('active')) return;

            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(earthGroup.children[0]); // intersect the base sphere

            if (intersects.length > 0) {
                const point = intersects[0].point;
                // Convert Cartesian to spherical coordinates
                const x = point.x, y = point.y, z = point.z;
                const r = Math.sqrt(x*x + y*y + z*z);
                const lat = 90 - (Math.acos(y / r) * 180 / Math.PI);
                const lng = (Math.atan2(z, x) * 180 / Math.PI) % 360;
                selectedLat = lat;
                selectedLng = lng;
                document.getElementById('coords').innerText = `LAT: ${lat.toFixed(2)}¬∞ LONG: ${lng.toFixed(2)}¬∞`;
                
                // Open drawing panel
                document.getElementById('drawing-panel').classList.add('active');
                controls.autoRotate = false; // pause rotation while drawing
            }
        });

        // --- Cancel drawing ---
        document.getElementById('cancel-draw').addEventListener('click', () => {
            document.getElementById('drawing-panel').classList.remove('active');
            controls.autoRotate = true;
        });

        // --- Save landmark ---
        document.getElementById('save-landmark').addEventListener('click', async () => {
            const name = document.getElementById('landmark-name').value.trim();
            if (!name) {
                alert('ENTER DESIGNATION');
                return;
            }
            
            // Get drawing as base64 PNG
            const drawingData = canvas.toDataURL('image/png'); // includes mime type
            
            const payload = {
                name,
                lat: selectedLat,
                lng: selectedLng,
                drawing_data: drawingData
            };

            document.getElementById('status').innerText = 'STATUS: UPLOADING...';
            
            try {
                const response = await fetch(API_BASE, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error('Upload failed');
                const landmark = await response.json();
                document.getElementById('status').innerText = 'STATUS: LANDMARK SAVED';
                // Add the new landmark to the scene immediately
                addLandmarkPlane(landmark);
                // Clear and close
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                document.getElementById('landmark-name').value = '';
                document.getElementById('drawing-panel').classList.remove('active');
                controls.autoRotate = true;
            } catch (err) {
                document.getElementById('status').innerText = 'STATUS: ERROR - ' + err.message;
                console.error(err);
            }
        });

        // --- Landmark planes (always face camera) ---
        const landmarkGroup = new THREE.Group();
        scene.add(landmarkGroup);

        function addLandmarkPlane(landmark) {
            const { lat, lng, drawing_data, name } = landmark;
            
            // Load image from base64
            const img = new Image();
            img.src = drawing_data;
            img.onload = () => {
                const texture = new THREE.CanvasTexture(img); // img is an HTMLImageElement
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                
                // Plane geometry: 0.8 units wide, keep aspect ratio
                const aspect = img.width / img.height;
                const width = 1.2;
                const height = width / aspect;
                
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    depthTest: true,
                    depthWrite: false,
                    blending: THREE.NormalBlending
                });
                const sprite = new THREE.Sprite(material);
                
                // Position on sphere surface
                const phi = (90 - lat) * Math.PI / 180;
                const theta = lng * Math.PI / 180;
                const r = EARTH_RADIUS + 0.15; // slightly above surface
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                
                sprite.position.set(x, y, z);
                sprite.scale.set(width, height, 1);
                
                // Store name in userData for tooltip later (optional)
                sprite.userData = { name };
                
                landmarkGroup.add(sprite);
            };
        }

        // --- Fetch existing landmarks ---
        async function fetchLandmarks() {
            try {
                const response = await fetch(API_BASE);
                if (!response.ok) throw new Error('Failed to fetch');
                const landmarks = await response.json();
                landmarks.forEach(addLandmarkPlane);
                document.getElementById('status').innerText = `STATUS: ${landmarks.length} LANDMARKS ONLINE`;
            } catch (err) {
                document.getElementById('status').innerText = 'STATUS: FETCH ERROR';
                console.error(err);
            }
        }
        fetchLandmarks();

        // --- Animation loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // handles autoRotate if enabled
            renderer.render(scene, camera);
        }
        animate();

        // --- Handle window resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Update coordinates display on mouse move (optional) ---
        renderer.domElement.addEventListener('mousemove', (event) => {
            // can add real-time coordinate display on hover if desired
        });
    </script>
</body>
</html>
